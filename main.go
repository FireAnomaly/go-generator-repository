package main

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	ErrMigrationNotFound = errors.New("migration not found")
	ErrInvalidMigration  = errors.New("migration is not valid")
	ErrInvalidRegExp     = errors.New("invalid regexp")
)

const structTemplate = `package {{.PackageName}}

// Code generated by sql2struct. DO NOT EDIT.

type {{.StructName}} struct {
    {{- range .Columns}}
    {{.Name}} {{.Type}} ` + "`" + `db:"{{.DBTag}}"` + "`" + `
    {{- end}}
}
`

type TemplateColumn struct {
	Name  string
	Type  string
	DBTag string
}

type Column struct {
	Name   string
	Type   string
	IsNull bool
}

func main() {
	migration := "db/migrations"
	paths, err := GetPaths(migration)
	if err != nil {
		panic(err)
	}

	for _, path := range paths {
		var fileInfo []byte
		fileInfo, err = os.ReadFile(path)
		if err != nil {
			panic(err)
		}

		TableName, err := GetTableName(fileInfo)
		if err != nil {
			panic(err)
		}

		fmt.Printf("Table name:%s \n", TableName)

		columns, err := GetColumns(fileInfo)
		if err != nil {
			panic(err)
		}

		fmt.Println(columns)

	}

}

func GetColumns(fileInfo []byte) ([]Column, error) {
	startColumns := strings.Index(string(fileInfo), "(")
	endColumns := strings.LastIndex(string(fileInfo), ")")

	rowsColumns := string(fileInfo)[startColumns+1 : endColumns]

	lines := strings.Split(rowsColumns, "\n")

	var columns []Column
	reColumn, err := regexp.Compile(`^\s*(\w+)\s+(\w+(?:\(\d+(?:,\s*\d+)?\))?)`)
	if err != nil {
		return nil, err
	}

	for _, line := range lines {
		line = strings.TrimSpace(line)
		line = strings.TrimSuffix(line, ",")

		matches := reColumn.FindStringSubmatch(line)
		if len(matches) < 3 {
			continue
		}

		column := Column{
			Name:   matches[1],
			Type:   matches[2],
			IsNull: !strings.Contains(line, "NOT NULL"),
		}

		columns = append(columns, column)
	}

	return columns, nil
}

func GetTableName(file []byte) (string, error) {
	patternTableName := `(?i)CREATE\s+TABLE\s+\w+`
	reTableName, err := regexp.Compile(patternTableName)
	if err != nil {
		return "", fmt.Errorf("failed get structure name: %w", err)
	}

	finded := reTableName.FindString(string(file))

	tableName := strings.TrimLeft(finded, "CREATE TABLE ")

	return toCamelCase(tableName), nil
}

func toCamelCase(snakeCase string) string {
	unFormatedNames := strings.Split(snakeCase, "_")

	names := make([]string, 0, len(unFormatedNames))
	for _, v := range unFormatedNames {
		titleName := strings.ToTitle(v[:1])
		toCompileName := titleName + v[1:]
		names = append(names, toCompileName)
	}

	return strings.Join(names, "")

}

func GetPaths(migration string) ([]string, error) {
	pattern := fmt.Sprintf("%s/*.sql", migration)

	paths, err := filepath.Glob(pattern)
	if err != nil {
		return nil, fmt.Errorf("error finding migrations: %w", err)
	}

	if len(paths) == 0 {
		return nil, ErrMigrationNotFound
	}

	fmt.Printf("Found %d migrations\n", len(paths))

	return paths, nil
}
